// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

// In this file, we will analyze the shape of the calldata for multiple functions that include dynamic
// length arguments. We will run the transaction then copy the calldata and format it to separate words
contract YulVariableLength {
    struct Example {
        uint256 a;
        uint256 b;
        uint256 c;
    }

    /**
        4-byte selector: c6f922d0
        call: threeArgs(7, [1, 2, 3], 9)
        formatted calldata:
        0x00: 0000000000000000000000000000000000000000000000000000000000000007
        0x20: 0000000000000000000000000000000000000000000000000000000000000060
        0x40: 0000000000000000000000000000000000000000000000000000000000000009
        0x60: 0000000000000000000000000000000000000000000000000000000000000003
        0x80: 0000000000000000000000000000000000000000000000000000000000000001
        0xa0: 0000000000000000000000000000000000000000000000000000000000000002
        0xc0: 0000000000000000000000000000000000000000000000000000000000000003
    
        The first and the third lines (0x00 & 0x40) correspond to the first and the third word pass to the fn
        The second line (0x20) is a pointer to the argument pointer of the calldata where the variable length data begins
        The fourth line (0x60) tell how many elements are in the array (3 in this case) 
        The last three lines (0x80, 0xa0, 0xc0) correspond to the array elements (1, 2, 3)

        note: we need the second/fourth lines because else we would not know how many elements are in the array
     */
    function threeArgs(
        uint256 a,
        uint256[] calldata b,
        uint256 c
    ) external {}

    /**
        4-byte selector: 290e7f9e
        call: threeArgsStruct(7, [1, 2, 3], 9)
        formatted calldata:
        0x00: 0000000000000000000000000000000000000000000000000000000000000007
        0x20: 0000000000000000000000000000000000000000000000000000000000000001
        0x40: 0000000000000000000000000000000000000000000000000000000000000002
        0x60: 0000000000000000000000000000000000000000000000000000000000000003
        0x80: 0000000000000000000000000000000000000000000000000000000000000009
    
        The first and the last lines (0x00 & 0x80) correspond to the first and the third word pass to the function
        The three lines in between (0x20, 0x40, 0x60) are the struct elements in the order they are pass to the function

        note: elements are directly passed as is because we know the length of the structure in advance
     */
    function threeArgsStruct(
        uint256 a,
        Example calldata b,
        uint256 c
    ) external {}

    /**
        4-byte selector: 37701841
        call: fiveArgs(5, [2, 4], 7, [10, 11, 12], 9)
        formatted calldata:
        0x00 : 0000000000000000000000000000000000000000000000000000000000000005
        0x20 : 00000000000000000000000000000000000000000000000000000000000000a0
        0x40 : 0000000000000000000000000000000000000000000000000000000000000007
        0x60 : 0000000000000000000000000000000000000000000000000000000000000100
        0x80 : 0000000000000000000000000000000000000000000000000000000000000009
        0xa0 : 0000000000000000000000000000000000000000000000000000000000000002
        0xc0 : 0000000000000000000000000000000000000000000000000000000000000002
        0xe0 : 0000000000000000000000000000000000000000000000000000000000000004
        0x100: 0000000000000000000000000000000000000000000000000000000000000003
        0x120: 000000000000000000000000000000000000000000000000000000000000000a
        0x140: 000000000000000000000000000000000000000000000000000000000000000b
        0x160: 000000000000000000000000000000000000000000000000000000000000000c
    
        Similar to threeArgs in the construction
     */
    function fiveArgs(
        uint256 a,
        uint256[] calldata b,
        uint256 c,
        uint256[] calldata d,
        uint256 e
    ) external {}

    /**
        4-byte selector: da02ff3c
        call: oneArg([1, 2, 3])
        formatted calldata:
        0x00: 0000000000000000000000000000000000000000000000000000000000000020
        0x20: 0000000000000000000000000000000000000000000000000000000000000003
        0x40: 0000000000000000000000000000000000000000000000000000000000000001
        0x60: 0000000000000000000000000000000000000000000000000000000000000002
        0x80: 0000000000000000000000000000000000000000000000000000000000000003
    
        note: even when the dynamic argument is the only argument, we still need to pass a pointer to the beginning of the array
     */
    function oneArg(uint256[] calldata a) external {}

    /**
        4-byte selector: 1fd3b26b
        call: allVariable([1,2,4], [10,11], [10, 11, 12])
        formatted calldata:
        0x00 : 0000000000000000000000000000000000000000000000000000000000000060
        0x20 : 00000000000000000000000000000000000000000000000000000000000000e0
        0x40 : 0000000000000000000000000000000000000000000000000000000000000140
        0x60 : 0000000000000000000000000000000000000000000000000000000000000003
        0x80 : 0000000000000000000000000000000000000000000000000000000000000001
        0xa0 : 0000000000000000000000000000000000000000000000000000000000000002
        0xc0 : 0000000000000000000000000000000000000000000000000000000000000004
        0xe0 : 0000000000000000000000000000000000000000000000000000000000000002
        0x100: 00000000000000000000000000000000000000000000000000000000000000a
        0x120: 000000000000000000000000000000000000000000000000000000000000000b
        0x140: 0000000000000000000000000000000000000000000000000000000000000003
        0x160: 000000000000000000000000000000000000000000000000000000000000000a
        0x180: 000000000000000000000000000000000000000000000000000000000000000b
        0x1a0: 000000000000000000000000000000000000000000000000000000000000000c
    
        Similar to threeArgs in the construction
     */
    function allVariable(
        uint256[] calldata a,
        uint256[] calldata b,
        uint256[] calldata c
    ) external {}
}
